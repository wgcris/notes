以WordCount分析
一 程序的提交
WordCount::main
	GenericOptionsParser					//处理传入参数加入到conf中
	Job.getInstance							//构造一个Job对象
		getInstance
			构造JobConf对象，并传入配置参数conf
			构造Job对象
				super					//即初始化JobContextImpl父类的成员，讲conf和一个null的id传入其中
				证书相关(略)
				this.cluster设置为null
		setJobName				
	setJarByClass								
	setMapperClass
	setCombinerClass
	setReducerClass
	setOutputKeyClass
	setOutputValueClass					//以上是一些设置，设置到了jobconf中
	设置输出输出目录等工作
	waitForCompletion						//org.apache.hadoop.mapreduce.Job.waitForCompletion
		submit										//只要为DEFINE状态才提交
			setUseNewAPI						//除非有特别配置，否则使用新的api
			connect									//构造job.cluster，这里Cluster对象是集群的抽象，可以跟AM通信
				设置conf,ugi	
				构造Cluster对象						
					initialize
						这里使用了ServiceLoader技术, 会把所有ClientProtocolProvider的子类加载到frameworkLoader。然后根据配置的mapreduce的框架选择provider，并赋值给clientProtocolProvider(clientProtocolProvider.create赋值给client)。这里配置了yarn, 因此选择YarnClientProtocolProvider。对于YarnClientProtocolProvider的create返回为YarnRunner(conf),赋值给client。
						这里构造的client对象是与ClientProtocol的实现，是客户端与AM通信的对象。
			构造submitter
			submitter.submitJobInternal		//使用当前用户(即客户端的用户)提交job
				checkSpecs
				获取配置conf
				addMRFrameworkToDistributedCache



				设置jobStagingArea							//最终会调用YarnRunner::getStagingAreaDir => ResourceMgrDelegate::getStagingAreaDir => MRApps::getStagingAreaDir, 然后访问yarn.app.mapreduce.am.staging-dir, 线上集群设置为/user。所以最后为/user/${user}/.staging
				...				
				设置submitJobDir								//最后为	/user/${user}/.staging/${appid}
				...			
				copyAndConfigureFiles
					构造JobResourceUploader
					uploadFiles									//会把指定文件拷贝到hdfs
					getWorkingDirectory					
				...
				writeSplits										//创建split
					writeNewSplits
						获取InputFormat对象input,根据JobContextImpl::getInputFormatClass可知默认使用TextInputFormat，这里以它做分析。
						排列inputsplit, 返回map的数目
				设置queue,acl
				将配置信息job.xml写到hdfs中
				submitClient.submitJob			//submitClient为YarnRunner				
					appContext								//构造一些启动参数，其中包括要启动的appmaster的类和参数等。其中要启动类为org.apache.hadoop.mapreduce.v2.app.MRAppMaster
					submitApplication					//ResourceMgrDelegate::submitApplication => YarnClientImpl::submitApplication向RM发送获取app请求。通过代理向RM发送提交app请求。
					getApplicationReport
					getYarnApplicationState		//判断提交job情况
					getJobStatus							//返回状态
			...
		monitorAndPrintJob							//根据传入参数判断是否监控
		不断通过isComplete判断job是否完成，未完成继续休眠指定时间(由mapreduce.client.completion.pollinterval指定)
	

——————————————————————————————————————
!!!!!这里暂时缺少RM部署MRAPP的过程!!!!!
——————————————————————————————————————


二 MRAppMaster的分析
main
	...
	initAndStartAppMaster
		appmaster.init
			serviceInit					//间接调用
				开启各种服务，注册handler等。
		appMaster.start
			serviceStart				//间接调用
			设置containerAllocator					//非uber模式，使用了类RMContainerAllocator
				RMContainerAllocator::serviceInit				//间接调用,简单配置
				RMContainerAllocator::serviceStart
					配置一个线程类，有一个while循环，不断地从事件队列中取事件，
						handleEvent			//并处理事件,根据事件处理
							如果是CONTAINER_REQ事件，检查Capability，满足增加为map
							如果是CONTAINER_DEALLOCATE事件，释放资源
							如果是CONTAINER_FAILED事件，...
					然后启动该线程类
				startJobs



					
附录A 配置的说明
mapreduce.client.completion.pollinterval				//表示客户端循环判断job是否完成的时间间隔

